<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>JMS Transpose Live</title>
    <link rel="icon" type="image/png" href="logo.png" />
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            padding: 10px;
            margin: 0;
        }
        h1 {
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, serif;
            font-size: 1.8em;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 15px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .accidentals-notes-chords {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        .radio-button-group {
            display: flex;
            flex: 1;
            justify-content: space-between;
        }
        .radio-button {
            flex: 1;
            text-align: center;
            padding: 8px;
            font-size: 0.9em;
            border: 2px solid #3498db;
            background-color: white;
            color: #3498db;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            user-select: none;
        }
        .radio-button.selected {
            background-color: #3498db;
            color: white;
        }
        input[type="radio"] {
            display: none;
        }
        .note-group {
            display: inline-block;
            position: relative;
        }
        .dot {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            font-weight: bold;
            color: inherit;
        }
        .dot-above {
            top: -0.8em;
        }
        .dot-below {
            bottom: -0.6em;
        }
        .note-wrapper {
            display: inline-block;
            font-family: inherit;
        }
        .sharp {
            font-size: 0.8em;
            vertical-align: super;
        }
        .flat {
            font-size: 0.8em;
            vertical-align: sub;
        }
        #inputTextArea {
            width: 100%;
            min-height: 200px;
            max-height: 400px;
            font-family: monospace;
            font-size: 1.2em;
            border: 1px solid #bbb;
            padding: 12px;
            white-space: pre;
            word-wrap: break-word;
            overflow-y: auto;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            outline: none;
            transition: box-shadow 0.3s ease;
            vertical-align: baseline;
        }
        #inputTextArea sup, #inputTextArea sub {
            font-size: 0.75em;
            vertical-align: baseline;
            font-family: Arial, sans-serif;
            line-height: 1;
            user-select: none;
        }
        #inputTextArea:focus {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        label {
            font-weight: bold;
            font-size: 0.9em;
            user-select: none;
        }
        input[type="text"], input[type="number"] {
            padding: 8px;
            border: 1px solid #bbb;
            border-radius: 4px;
            font-size: 1em;
            box-sizing: border-box;
            width: 100%;
        }
        button {
            background-color: #3498db;
            color: white;
            padding: 8px;
            font-size: 0.9em;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            user-select: none;
        }
        button:hover:not(:disabled) {
            background-color: #2980b9;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .accidentals, .mode-selection {
            margin: 20px 0;
            text-align: center;
        }
        .blue-notes {
            color: #1e90ff;
        }
        .red-chords {
            color: #e74c3c;
        }
        .sharp, .flat {
            font-size: 0.9em;
            vertical-align: super;
        }
        .octave {
            font-size: 0.9em;
            vertical-align: sub;
        }
        .controls button, .controls input {
            flex: 1;
            min-width: 70px;
            margin: 0 5px;
        }
        .print-controls, .title-controls {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        .print-controls div, .title-controls div {
            flex: 1;
            display: flex;
            align-items: center;
        }
        .print-controls label, .title-controls label {
            font-weight: bold;
            margin-right: 5px;
            flex-shrink: 0;
        }
        .print-controls input, .title-controls input {
            flex: 1;
            padding: 8px;
            border: 1px solid #bbb;
            border-radius: 4px;
            font-size: 1em;
            box-sizing: border-box;
            width: 100%;
        }
        @media (max-width: 768px) {
            h1 {
                font-size: 1.5em;
            }
            .accidentals-notes-chords {
                flex-direction: row;
                justify-content: space-between;
            }
            .radio-button {
                font-size: 0.8em;
                padding: 6px;
            }
            .controls {
                flex-direction: row;
                align-items: center;
                justify-content: center;
            }
            .controls button {
                flex: 1;
                min-width: 70px;
            }
            .print-controls, .title-controls {
                flex-direction: row;
                flex-wrap: wrap;
                align-items: center;
                gap: 10px;
            }
            .print-controls div, .title-controls div {
                flex: 1;
                min-width: 150px;
            }
            .print-controls label, .title-controls label {
                margin-right: 5px;
            }
            .print-controls input, .title-controls input {
                width: calc(100% - 120px);
            }
            .controls input {
                width: 70px;
            }
        }

        /* Additional styling */
        .table-cell {
            text-align: center;
            padding: 0 10px;
            white-space: pre;
            display: inline-block;
            vertical-align: middle;
            line-height: 1.2;
        }
        .table-separator {
            display: inline-block;
            font-weight: bold;
            padding: 0 5px;
            vertical-align: middle;
            line-height: 1.2;
        }
        .green-section-label {
            font-weight: bold;
            color: green;
            display: inline;
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>JMS Transpose Live</h1>
        <div class="accidentals-notes-chords">
            <div class="radio-button-group" role="radiogroup" aria-label="Select accidental notation">
                <label class="radio-button selected" tabindex="0" aria-checked="true" role="radio" data-accidental="sharp">Sharps
                    <input type="radio" name="accidental" value="sharp" checked />
                </label>
                <label class="radio-button" tabindex="0" aria-checked="false" role="radio" data-accidental="flat">Flats
                    <input type="radio" name="accidental" value="flat" />
                </label>
            </div>
            <div class="radio-button-group" role="radiogroup" aria-label="Select mode">
                <label class="radio-button selected" tabindex="0" aria-checked="true" role="radio" data-mode="notes">Notes
                    <input type="radio" name="mode" value="notes" checked />
                </label>
                <label class="radio-button" tabindex="0" aria-checked="false" role="radio" data-mode="chords">Chords
                    <input type="radio" name="mode" value="chords" />
                </label>
                <label class="radio-button" tabindex="0" aria-checked="false" role="radio" data-mode="lyrics">Lyrics
                    <input type="radio" name="mode" value="lyrics" />
                </label>
            </div>
        </div>
        <div class="controls">
            <button id="transposeMinus" aria-label="Transpose down one semitone">-</button>
            <input type="number" id="semitoneValue" value="0" min="-12" max="12" readonly aria-label="Current semitone transposition" />
            <button id="transposePlus" aria-label="Transpose up one semitone">+</button>
            <button id="resetButton" aria-label="Reset transposition">Reset</button>
        </div>
        <div id="inputTextArea" contenteditable="true" placeholder="Enter notes, chords, or lyrics here..." aria-label="Input area for notes, chords, or lyrics" style="font-family: monospace; white-space: pre; border: 1px solid black; padding: 10px; width: 100%; height: 300px; overflow-y: auto;"></div>
        <div class="title-controls">
            <label for="username">Title:</label>
            <input type="text" id="username" placeholder="Enter Title" aria-label="Song title" />
        </div>
        <div class="print-controls">
            <div>
                <label for="key">Key:</label>
                <input type="text" id="key" placeholder="Enter Key" aria-label="Song key" />
            </div>
            <div>
                <label for="time">Time:</label>
                <input type="text" id="time" placeholder="Enter Time Signature" aria-label="Time signature" />
            </div>
        </div>
        <div class="controls">
            <button id="printBtn" aria-label="Print the transposed output">Print</button>
            <button id="saveBtn" aria-label="Save the current state as a new file">Save</button>
            <button id="updateBtn" aria-label="Update the current file" disabled>Update</button>
            <button id="importBtn" aria-label="Import a saved state">Open</button>
            <input type="file" id="importFile" style="display: none;" aria-label="File input for importing state" accept=".json" />
        </div>
    </div>

    <script>
        // Variables and constants
        const inputTextArea = document.getElementById('inputTextArea');
        const semitoneValue = document.getElementById('semitoneValue');
        const transposeMinus = document.getElementById('transposeMinus');
        const transposePlus = document.getElementById('transposePlus');
        const resetButton = document.getElementById('resetButton');
        const accidentals = document.getElementsByName('accidental');
        const modes = document.getElementsByName('mode');
        const printBtn = document.getElementById('printBtn');
        const saveBtn = document.getElementById('saveBtn');
        const updateBtn = document.getElementById('updateBtn');
        const importBtn = document.getElementById('importBtn');
        const importFile = document.getElementById('importFile');
        const nameInput = document.getElementById('username');
        const keyInput = document.getElementById('key');
        const timeInput = document.getElementById('time');

        let semitones = 0;
        let originalText = '';
        let originalKey = '';
        let accidentalPreference = 'sharp';
        let modePreference = 'notes';
        let jmsDirHandle = null;
        let currentFileHandle = null;
        let currentSubfolderHandle = null;

        const sharpNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const flatNotes = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
        const validChordExtensions = ['maj7', 'm7', 'm', 'M', 'dim', 'aug', 'sus2', 'sus4', 'add9', '7', '6', '9', '11', '13'];

        // IndexedDB setup for storing directory handle
        const DB_NAME = 'JmsTransposeLive';
        const STORE_NAME = 'directoryHandles';
        let db;

        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    db.createObjectStore(STORE_NAME);
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function saveDirectoryHandle(handle) {
            const db = await openIndexedDB();
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            store.put(handle, 'jmsDirHandle');
            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            });
        }

        async function getDirectoryHandle() {
            const db = await openIndexedDB();
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get('jmsDirHandle');
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Initialize JMS folder and subfolders on page load
        async function initJmsFolder() {
            if (!window.showDirectoryPicker) {
                console.warn('File System Access API not supported. Falling back to default save.');
                return null;
            }
            try {
                // Check for stored directory handle
                if (!jmsDirHandle) {
                    const storedHandle = await getDirectoryHandle();
                    if (storedHandle) {
                        // Verify permission
                        const permission = await storedHandle.queryPermission({ mode: 'readwrite' });
                        if (permission === 'granted') {
                            jmsDirHandle = storedHandle;
                        } else if (permission === 'prompt') {
                            const granted = await storedHandle.requestPermission({ mode: 'readwrite' });
                            if (granted === 'granted') {
                                jmsDirHandle = storedHandle;
                            }
                        }
                    }
                }

                // Prompt for directory if no valid handle
                if (!jmsDirHandle) {
                    const baseDirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                    jmsDirHandle = await baseDirHandle.getDirectoryHandle('JMS', { create: true });
                    await saveDirectoryHandle(jmsDirHandle);
                }

                // Create or get subfolders
                await Promise.all([
                    jmsDirHandle.getDirectoryHandle('CHORDS', { create: true }),
                    jmsDirHandle.getDirectoryHandle('NOTES', { create: true }),
                    jmsDirHandle.getDirectoryHandle('LYRICS', { create: true })
                ]);
                return jmsDirHandle;
            } catch (error) {
                console.error('Error initializing JMS folder:', error);
                alert('Failed to set up local storage. Using default save method.');
                return null;
            }
        }

        // Get subfolder handle based on mode
        async function getSubfolderHandle(mode) {
            if (!jmsDirHandle) {
                jmsDirHandle = await initJmsFolder();
            }
            if (!jmsDirHandle) return null;
            const subfolder = mode.toUpperCase();
            try {
                return await jmsDirHandle.getDirectoryHandle(subfolder, { create: true });
            } catch (error) {
                console.error(`Error accessing ${subfolder} folder:`, error);
                return null;
            }
        }

        // Validate a note or chord
        function validateNoteOrChord(note, extension) {
            const isValidNote = sharpNotes.includes(note) || flatNotes.includes(note);
            const isValidExtension = !extension || validChordExtensions.includes(extension);
            return isValidNote && isValidExtension;
        }

        // Sanitize HTML to prevent XSS
        function sanitizeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function transposeNote(note, shift) {
            const notes = accidentalPreference === 'sharp' ? sharpNotes : flatNotes;
            const index = sharpNotes.indexOf(note) !== -1 ? sharpNotes.indexOf(note) : flatNotes.indexOf(note);
            if (index === -1) {
                console.warn(`Invalid note: ${note}`);
                return note;
            }
            const transposedIndex = (index + shift + 12) % 12;
            return notes[transposedIndex];
        }

        function transposeText(text, shift) {
            return text.replace(/([A-G][#b]*)([\(\)\[\]]?)(maj7|m7|m|M|dim|aug|sus2|sus4|add9|7|6|9|11|13)?/g, (match, note, octave, extension) => {
                if (!validateNoteOrChord(note, extension)) return match;
                return transposeNote(note, shift) + (octave || '') + (extension || '');
            });
        }

        function applyAccidentalPreference(text) {
            return text.replace(/([A-G][#b]*)([\(\)\[\]]?)(maj7|m7|m|M|dim|aug|sus2|sus4|add9|7|6|9|11|13)?/g, (match, note, octave, extension) => {
                const index = sharpNotes.indexOf(note) !== -1 ? sharpNotes.indexOf(note) : flatNotes.indexOf(note);
                if (index === -1) return match;
                const notes = accidentalPreference === 'sharp' ? sharpNotes : flatNotes;
                return notes[index] + (octave || '') + (extension || '');
            });
        }

        function applyColorAndDots(text) {
            if (modePreference === 'lyrics') {
                return text;
            }
            return text.replace(
                /([A-G])([#b]?)(['.]?)(maj7|m7|m|M|dim|aug|sus2|sus4|add9|7|6|9|11|13)?/g,
                (match, note, accidental, sign, extension) => {
                    const colorClass = modePreference === 'notes' ? 'blue-notes' : 'red-chords';
                    let formattedNote = `<span class="note-wrapper">${note}`;
                    if (accidental === '#') {
                        formattedNote += `<span class="sharp">#</span>`;
                    } else if (accidental === 'b') {
                        formattedNote += `<span class="flat">b</span>`;
                    }
                    formattedNote += `</span>`;
                    return `<span class="${colorClass} note-group">${formattedNote}${sign.replace("+", "'").replace("-", ".")}${extension ? `<span class="${colorClass}">${extension}</span>` : ''}</span>`;
                }
            );
        }

        function formatText(text) {
            if (!text.trim()) {
                return '';
            }
            if (modePreference === 'lyrics') {
                return text.replace(/<([^>]+?)>/g, (match, content) => {
                    content = content.trim();
                    return /^[\p{L}\p{M}0-9\s]+$/u.test(content) && content ? `<span contenteditable="false" class="green-section-label">${content}</span>` : match;
                });
            }
            text = text.replace(/<([^>]+?)>/g, (match, content) => {
                content = content.trim();
                return /^[\p{L}\p{M}0-9\s]+$/u.test(content) && content ? `<span contenteditable="false" class="green-section-label">${content}</span>` : match;
            });
            const lines = text.split('\n');
            const formattedLines = lines.map(line => {
                if (!line.trim()) return '';
                if (line.includes('|')) return line;
                return applyColorAndDots(line);
            });
            const tableData = [];
            let maxCols = 0;
            lines.forEach(line => {
                if (line.trim() && line.includes('|')) {
                    const cols = line.split('|').map(col => col);
                    maxCols = Math.max(maxCols, cols.length);
                    tableData.push(cols);
                }
            });
            tableData.forEach(row => {
                while (row.length < maxCols) {
                    row.push('');
                }
            });
            const colWidths = new Array(maxCols).fill(0);
            tableData.forEach(row => {
                row.forEach((col, i) => {
                    colWidths[i] = Math.max(colWidths[i], col.length, 2);
                });
            });
            let tableRowIndex = 0;
            for (let i = 0; i < formattedLines.length; i++) {
                if (!lines[i].trim() || !lines[i].includes('|')) {
                    continue;
                }
                const cols = tableData[tableRowIndex];
                const formattedRow = cols.map((col, j) => {
                    const paddedCol = col.padEnd(colWidths[j], ' ');
                    return `<span class='table-cell' style='display: inline-block; width: ${colWidths[j] * 8}px'>${applyColorAndDots(paddedCol)}</span>`;
                }).join('<span class="table-separator">|</span>');
                formattedLines[i] = formattedRow;
                tableRowIndex++;
            }
            const result = formattedLines.join('<br>');
            return result;
        }

        // Move caret to end
        function placeCaretAtEnd(el) {
            el.focus();
            const range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }

        // Updates the transposition display and key
        function updateTransposition() {
            let currentText = modePreference === 'lyrics' ? originalText : transposeText(originalText, semitones);
            if (modePreference !== 'lyrics') {
                currentText = applyAccidentalPreference(currentText);
            }
            inputTextArea.innerHTML = '';
            inputTextArea.innerHTML = formatText(currentText);
            placeCaretAtEnd(inputTextArea);

            let currentKey = modePreference === 'lyrics' ? originalKey : transposeText(originalKey, semitones);
            if (modePreference !== 'lyrics') {
                currentKey = applyAccidentalPreference(currentKey);
            }
            keyInput.value = currentKey;
        }

        // Parse inputTextArea content to plain text (remove formatting spans)
        function handleInputChange() {
            const clone = inputTextArea.cloneNode(true);
            clone.querySelectorAll('.green-section-label').forEach(span => {
                span.replaceWith(document.createTextNode(`<${span.textContent}>`));
            });
            const walker = document.createTreeWalker(clone, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT);
            let currentText = '';
            let lastNodeWasBlock = false;
            while (walker.nextNode()) {
                const node = walker.currentNode;
                if (node.nodeType === Node.ELEMENT_NODE) {
                    if (node.tagName === 'BR') {
                        currentText += '\n';
                        lastNodeWasBlock = true;
                    } else if (node.tagName === 'DIV') {
                        if (!lastNodeWasBlock) {
                            currentText += '\n';
                        }
                        lastNodeWasBlock = true;
                    } else {
                        lastNodeWasBlock = false;
                    }
                } else if (node.nodeType === Node.TEXT_NODE) {
                    currentText += node.textContent;
                    lastNodeWasBlock = false;
                }
            }
            if (lastNodeWasBlock) {
                currentText += '\n';
            }

            if (semitones === 0 || modePreference === 'lyrics') {
                originalText = currentText;
            } else {
                // Undo transposition to store original (untransposed) text
                originalText = transposeText(currentText, -semitones);
            }
        }

        // Debounce input handler for performance
        let inputChangeTimeout;
        function handleInputChangeDebounced() {
            clearTimeout(inputChangeTimeout);
            inputChangeTimeout = setTimeout(() => {
                handleInputChange();
            }, 300);
        }

        // Transpose button handlers
        function handleTransposeClick(direction) {
            let newSemitones = semitones;
            if (direction === 'minus' && semitones > -12) {
                newSemitones--;
            } else if (direction === 'plus' && semitones < 12) {
                newSemitones++;
            } else {
                return;
            }
            semitones = newSemitones;
            semitoneValue.value = semitones;
            updateTransposition();
        }

        // Reset button handler
        function reset() {
            semitones = 0;
            semitoneValue.value = 0;
            inputTextArea.innerHTML = formatText(originalText);
            keyInput.value = originalKey;
            updateTransposition();
        }

        // Key input change handler
        function handleKeyInputChange() {
            const currentKey = keyInput.value;
            if (semitones === 0 || modePreference === 'lyrics') {
                originalKey = currentKey;
            } else {
                originalKey = transposeText(currentKey, -semitones);
            }
        }

        // Print functionality
        function printOutput() {
            const name = sanitizeHTML(nameInput.value.trim());
            const key = sanitizeHTML(keyInput.value.trim());
            const keySignature = sanitizeHTML(timeInput.value.trim());
            const outputContent = inputTextArea.innerHTML;
            const printWindow = window.open('', '', 'width=800,height=600');
            printWindow.document.write('<html><head><title>Print Output</title>');
            printWindow.document.write('<style>');
            printWindow.document.write('@page { size: A4; margin: 1cm; }');
            printWindow.document.write('body { font-weight: bold; font-family: monospace; white-space: pre; }');
            printWindow.document.write('.blue-notes { color: blue; }');
            printWindow.document.write('.red-chords { color: red; }');
            printWindow.document.write('.sharp { font-size: 0.8em; vertical-align: super; }');
            printWindow.document.write('.flat { font-size: 0.8em; vertical-align: super; }');
            printWindow.document.write('.dot { font-size: 0.8em; font-weight: bold; color: inherit; position: relative; display: inline-block; line-height: 1; }');
            printWindow.document.write('.dot-above, .dot-below { position: absolute; left: 50%; transform: translateX(-50%); white-space: nowrap; line-height: 1; }');
            printWindow.document.write('.dot-above { top: -1em; }');
            printWindow.document.write('.dot-below { bottom: -1em; }');
            printWindow.document.write('.table-cell { text-align: center; display: inline-block; padding: 0 10px; white-space: nowrap; position: relative; vertical-align: middle; line-height: 1; }');
            printWindow.document.write('.table-separator { display: inline-block; font-weight: bold; padding: 0 5px; }');
            printWindow.document.write('.green-section-label { font-weight: bold; color: green; display: inline; }');
            printWindow.document.write('.content-container { padding: 1cm; white-space: pre; margin: 0; box-sizing: border-box; text-align: justify; line-height: 1.4; }');
            printWindow.document.write('.header, .footer { text-align: center; font-size: 0.8em; position: fixed; width: 100%; background-color: white; box-sizing: border-box; }');
            printWindow.document.write('.header { top: 0; padding: 5px 0; border-bottom: 1px solid black; font-size: 1em; }');
            printWindow.document.write('.footer { bottom: 0; padding: 5px 0; border-top: 1px solid black; }');
            printWindow.document.write('</style></head><body>');
            printWindow.document.write('<div class="header">Sing to Him a new song; Play skillfully with a shout of joy. Psalm 33:3</div>');
            printWindow.document.write('<div class="content-container">');
            printWindow.document.write(`<h1 style="text-align: center; margin-top: 0;">${name}${key ? ' - ' + key : ''}${keySignature ? ' - ' + keySignature : ''}</h1>`);
            printWindow.document.write('<hr style="border: none; border-bottom: 2px solid black; margin: 10px 0;">');
            printWindow.document.write(outputContent);
            printWindow.document.write('</div>');
            printWindow.document.write('<div class="footer">created using johnmusicstudios.github.io/transposelive/</div>');
            printWindow.document.write('</body></html>');
            printWindow.document.close();
            printWindow.focus();
            printWindow.print();
        }

        // Save new file or overwrite existing - saveAndExport with handle update
        async function saveAndExport() {
            const name = nameInput.value.trim() || 'Untitled';
            const key = keyInput.value.trim();
            const keySignature = timeInput.value.trim();
            const state = {
                title: name,
                key: key,
                timeSignature: keySignature,
                content: originalText,
                accidentalPreference,
                modePreference,
                semitones: 0
            };
            const fileContent = JSON.stringify(state, null, 2);
            const fileName = `${name}${key ? '-' + key : ''}${keySignature ? '-' + keySignature : ''}.json`;

            if (window.showDirectoryPicker) {
                const subfolderHandle = await getSubfolderHandle(modePreference);
                if (subfolderHandle) {
                    try {
                        const fileHandle = await subfolderHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(fileContent);
                        await writable.close();
                        currentFileHandle = fileHandle;          // Update the current file handle
                        currentSubfolderHandle = subfolderHandle;
                        updateBtn.disabled = false;               // Enable update button
                        alert('File saved successfully to JMS/' + modePreference.toUpperCase() + '/' + fileName);
                        return;
                    } catch (error) {
                        console.error('Error saving file:', error);
                        alert('Failed to save file to local storage. Using default save method.');
                    }
                }
            }

            // Fallback: default download, no persistent handle available
            const blob = new Blob([fileContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
            currentFileHandle = null;
            currentSubfolderHandle = null;
            updateBtn.disabled = true;
        }

        // Update the currently opened file with new content
        async function updateExistingFile() {
            if (!currentFileHandle || !currentSubfolderHandle) {
                alert('No file is currently opened. Please open a file or use Save to create a new one.');
                return;
            }

            const name = nameInput.value.trim() || 'Untitled';
            const key = keyInput.value.trim();
            const keySignature = timeInput.value.trim();
            const state = {
                title: name,
                key: key,
                timeSignature: keySignature,
                content: originalText,
                accidentalPreference,
                modePreference,
                semitones: 0
            };
            const fileContent = JSON.stringify(state, null, 2);

            try {
                const writable = await currentFileHandle.createWritable();
                await writable.write(fileContent);
                await writable.close();
                alert('File updated successfully.');
            } catch (error) {
                console.error('Error updating file:', error);
                alert('Failed to update file.');
            }
        }

        // Import file and restore state
        async function importState(event) {
            let file = null, fileHandle = null;

            if (window.showDirectoryPicker) {
                try {
                    const subfolderHandle = await getSubfolderHandle(modePreference);
                    if (subfolderHandle) {
                        if (!event || !event.target || !event.target.files) {
                            const pickerResult = await window.showOpenFilePicker({
                                startIn: subfolderHandle,
                                types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }],
                                multiple: false
                            });
                            fileHandle = pickerResult[0];
                            file = await fileHandle.getFile();
                            currentFileHandle = fileHandle;
                            currentSubfolderHandle = subfolderHandle;
                            updateBtn.disabled = false;
                        }
                    }
                } catch (error) {
                    console.error('Error opening file:', error);
                    alert('Failed to open file from local storage. Using default open method.');
                }
            }

            if (!file && event && event.target && event.target.files) {
                file = event.target.files[0];
                currentFileHandle = null;
                currentSubfolderHandle = null;
                updateBtn.disabled = true;
            }

            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const state = JSON.parse(e.target.result);
                    if (!state.content || !state.accidentalPreference || !state.modePreference) {
                        throw new Error('Invalid JSON structure');
                    }

                    nameInput.value = state.title || '';
                    keyInput.value = state.key || '';
                    timeInput.value = state.timeSignature || '';
                    originalText = state.content || '';
                    originalKey = state.key || '';
                    semitones = 0;
                    semitoneValue.value = 0;
                    accidentalPreference = state.accidentalPreference || 'sharp';
                    modePreference = state.modePreference || 'notes';

                    document.querySelector(`input[name="accidental"][value="${accidentalPreference}"]`).checked = true;
                    document.querySelector(`input[name="mode"][value="${modePreference}"]`).checked = true;
                    setInitialSelected();

                    updateTransposition();
                } catch (error) {
                    alert('Error: Invalid or corrupted file. Please upload a valid JSON file.');
                    console.error('Import error:', error);
                    currentFileHandle = null;
                    currentSubfolderHandle = null;
                    updateBtn.disabled = true;
                }
            };
            reader.readAsText(file);
        }

        // Set the visual selected state of radio buttons
        function setInitialSelected() {
            const accidentalRadios = document.querySelectorAll('.radio-button-group input[name="accidental"]');
            accidentalRadios.forEach(radio => {
                radio.parentElement.classList.toggle('selected', radio.checked);
                radio.parentElement.setAttribute('aria-checked', radio.checked.toString());
            });
            const modeRadios = document.querySelectorAll('.radio-button-group input[name="mode"]');
            modeRadios.forEach(radio => {
                radio.parentElement.classList.toggle('selected', radio.checked);
                radio.parentElement.setAttribute('aria-checked', radio.checked.toString());
            });
        }

        // Disable update button and clear current file handles on mode or accidental change
        accidentals.forEach(radio => {
            radio.addEventListener('change', () => {
                accidentalPreference = document.querySelector('input[name="accidental"]:checked').value;
                currentFileHandle = null;
                currentSubfolderHandle = null;
                updateBtn.disabled = true;
                updateTransposition();
            });
        });

        modes.forEach(radio => {
            radio.addEventListener('change', () => {
                modePreference = document.querySelector('input[name="mode"]:checked').value;
                currentFileHandle = null;
                currentSubfolderHandle = null;
                updateBtn.disabled = true;
                updateTransposition();
            });
        });

        // Keyboard accessibility for radio buttons
        const accidentalRadios = document.querySelectorAll('.radio-button-group input[name="accidental"]');
        accidentalRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                accidentalRadios.forEach(r => {
                    r.parentElement.classList.remove('selected');
                    r.parentElement.setAttribute('aria-checked', 'false');
                });
                this.parentElement.classList.add('selected');
                this.parentElement.setAttribute('aria-checked', 'true');
            });
            radio.parentElement.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    radio.click();
                }
            });
        });

        const modeRadios = document.querySelectorAll('.radio-button-group input[name="mode"]');
        modeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                modeRadios.forEach(r => {
                    r.parentElement.classList.remove('selected');
                    r.parentElement.setAttribute('aria-checked', 'false');
                });
                this.parentElement.classList.add('selected');
                this.parentElement.setAttribute('aria-checked', 'true');
            });
            radio.parentElement.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    radio.click();
                }
            });
        });

        // Caret and key press management in input area - simplified and improved
        inputTextArea.addEventListener('keypress', function(event) {
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            const startContainer = range.startContainer;
            const parentElement = startContainer.nodeType === Node.ELEMENT_NODE ? startContainer : startContainer.parentNode;
            if (parentElement.closest('sup, sub')) {
                event.preventDefault();
                const target = parentElement.closest('sup, sub');
                range.setStartAfter(target);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }
        });

        inputTextArea.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const sel = window.getSelection();
                const range = sel.getRangeAt(0);
                let tableElement;
                const startContainer = range.startContainer;
                if (startContainer.nodeType === Node.ELEMENT_NODE) {
                    tableElement = startContainer.closest('.table-cell, .table-separator');
                } else {
                    tableElement = startContainer.parentNode.closest('.table-cell, .table-separator');
                }

                if (tableElement) {
                    const br = document.createElement('br');
                    tableElement.parentNode.insertBefore(br, tableElement.nextSibling);
                    range.setStartAfter(br);
                    range.setEndAfter(br);
                } else {
                    range.deleteContents();
                    const br = document.createElement('br');
                    range.insertNode(br);
                    range.setStartAfter(br);
                    range.setEndAfter(br);
                }
                sel.removeAllRanges();
                sel.addRange(range);
                handleInputChange();
            }
        });

        // Simplified caret repositioning on keyup and click inside a sup/sub to prevent cursor inside
        function fixCaretAfterSupSub() {
            const sel = window.getSelection();
            if (!sel.rangeCount) return;
            const range = sel.getRangeAt(0);
            const node = range.startContainer;
            const parent = node.nodeType === Node.ELEMENT_NODE ? node : node.parentNode;
            const target = parent.closest('sup, sub');
            if (target) {
                const newRange = document.createRange();
                newRange.setStartAfter(target);
                newRange.collapse(true);
                sel.removeAllRanges();
                sel.addRange(newRange);
            }
        }

        inputTextArea.addEventListener('keyup', fixCaretAfterSupSub);
        inputTextArea.addEventListener('click', fixCaretAfterSupSub);

        // Event Listener wiring
        transposeMinus.addEventListener('click', () => handleTransposeClick('minus'));
        transposePlus.addEventListener('click', () => handleTransposeClick('plus'));
        resetButton.addEventListener('click', reset);

        inputTextArea.addEventListener('input', handleInputChangeDebounced);
        keyInput.addEventListener('input', handleKeyInputChange);

        saveBtn.addEventListener('click', saveAndExport);
        updateBtn.addEventListener('click', updateExistingFile);
        importBtn.addEventListener('click', async () => {
            if (window.showDirectoryPicker) {
                await importState({});
            } else {
                importFile.click();
            }
        });
        importFile.addEventListener('change', importState);

        // Initialize visual selection of radio buttons on page load
        setInitialSelected();

        // Initialize JMS folder; and initialize original values on page load
        window.onload = async () => {
            await initJmsFolder();
            originalText = inputTextArea.innerText;
            originalKey = keyInput.value;
            updateTransposition();
            setInitialSelected();
        };
    </script>

</body>
</html>
